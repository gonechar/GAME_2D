


#include <iostream>
#include "sets_n_structs.h"
#include "EntityClass.h"

Entity::Entity(sf::String sImage, float X, float Y, sf::String Name){ //Конструктор с параметрами(формальными) для класса Player. При создании объекта класса мы будем задавать имя файла, координату Х и У, ширину и высоту

	x = X; y = Y;//двумерная координата появления спрайта
	dir = -1; 

	imageString = sImage;
	image.loadFromFile(imageString);

	w = image.getSize().x; //ширина 
	h = image.getSize().y;//высота
	dx = 0;	dy = 0;
	currentSpeed, speed, moveTimer = 0;

	name = Name; 

	
	//life = true;//инициализировали логическую переменную жизни
	isMove = false;

	//image.loadFromFile("images/APlayer/" + File);//кладем в image наше изображение вместо File мы передадим то, что пропишем при создании объекта. В нашем случае "hero.png" и получится запись идентичная image.loadFromFile("images/hero/png");
	

	texture.loadFromImage(image);//закидываем наше изображение в текстуру
	sprite.setTexture(texture);//заливаем спрайт текстурой

	


	sprite.setTextureRect(sf::IntRect(0, 0, w, h)); //Задаем спрайту один прямоугольник для вывода одного персонажа, а не всего спрайта сразу. IntRect - приведение типов
	sprite.setOrigin(w / 2, h / 2);
};

void Entity::update(float time, sf::String *TileMap){//функция "оживления" объекта класса. update - обновление. принимает в себя время SFML , вследствие чего работает бесконечно, давая персонажу движение.

	

	switch (dir)//реализуем поведение в зависимости от направления. (каждая цифра соответствует направлению)
	{
	case RIGHT_2D: dx = speed; 	dy = 0;	break;//по иксу задаем положительную скорость, по игреку зануляем. получаем, что персонаж идет только вправо
	case LEFT_2D: dx = -speed; dy = 0; break;//по иксу задаем отрицательную скорость, по игреку зануляем. получается, что персонаж идет только влево
	case DOWN_2D: dx = 0; dy = speed; break;//по иксу задаем нулевое значение, по игреку положительное. получается, что персонаж идет только вниз
	case UP_2D: dx = 0; dy = -speed; break;//по иксу задаем нулевое значение, по игреку отрицательное. получается, что персонаж идет только вверх
	}

	x += dx*time;//то движение из прошлого урока. наше ускорение на время получаем смещение координат и как следствие движение
	mapReaction(TileMap, time);//вызываем функцию, отвечающую за взаимодействие с картой

	y += dy*time;//аналогично по игреку
	mapReaction(TileMap, time);//вызываем функцию, отвечающую за взаимодействие с картой

	speed = 0;//зануляем скорость, чтобы персонаж остановился.
	sprite.setPosition(x + w / 2, y + h / 2); //выводим спрайт в позицию x y , посередине. бесконечно выводим в этой функции, иначе бы наш спрайт стоял на месте.


};

sf::FloatRect Entity::getRect(){
	return sf::FloatRect(x, y, w, h);
}


void Entity::mapReaction(sf::String *TileMap, float time)//ф-ция взаимодействия с картой
{
	for (int i = y / (tileMapSize); i < (y + h) / (tileMapSize); i++)//проходимся по всей карте, то есть по всем квадратикам размера 32*32, которые мы окрашивали в 9 уроке. про условия читайте ниже.
	for (int j = x / (tileMapSize); j<(x + w) / (tileMapSize); j++)//икс делим на 32, тем самым получаем левый квадратик, с которым персонаж соприкасается. (он ведь больше размера 32*32, поэтому может одновременно стоять на нескольких квадратах). А j<(x + w) / 32 - условие ограничения координат по иксу. то есть координата самого правого квадрата, который соприкасается с персонажем. таким образом идем в цикле слева направо по иксу, проходя по от левого квадрата (соприкасающегося с героем), до правого квадрата (соприкасающегося с героем)
	{
		if (TileMap[i][j] == '0')//если наш квадратик соответствует символу 0 (стена), то проверяем "направление скорости" персонажа:
		{
			if (dy>0)//если мы шли вниз,
			{

				y = i * (tileMapSize)-h;//то стопорим координату игрек персонажа. сначала получаем координату нашего квадратика на карте(стены) и затем вычитаем из высоты спрайта персонажа.
			}
			if (dy<0)
			{

				y = i * (tileMapSize)+tileMapSize;//аналогично с ходьбой вверх. dy<0, значит мы идем вверх (вспоминаем координаты паинта)
			}
			if (dx>0)
			{

				x = j * (tileMapSize)-w;//если идем вправо, то координата Х равна стена (символ 0) минус ширина персонажа
			}
			if (dx < 0)
			{

				x = j * (tileMapSize)+tileMapSize;//аналогично идем влево
			}
		}
	}
}


float Entity::getCoordinateX(){	//этим методом будем забирать координату Х	
	return x;
}

float Entity::getCoordinateY(){	//этим методом будем забирать координату Y 	
	return y;
}

float Entity::changeCoordinateX_by(float addX){	//этим методом будем забирать координату Х	
	x += addX;
	return x;
}

float Entity::changeCoordinateY_by(float addY){	//этим методом будем забирать координату Y 	
	y += addY;
	return y;
}

float Entity::changeCoordinateX_to(float newX){	//этим методом будем забирать координату Х	
	x = newX;
	return x;
}

float Entity::changeCoordinateY_to(float newY){	//этим методом будем забирать координату Y 	
	y = newY;
	return y;
}



